#!/bin/sh

#
# PROVIDE: jenkins
# REQUIRE: LOGIN
# KEYWORD: shutdown
#
# Configuration settings for jenkins in /etc/rc.conf:
#
# jenkins_enable (bool):
#   Set to "NO" by default.
#   Set it to "YES" to enable jenkins
#

. /etc/rc.subr

name="jenkins"
rcvar="jenkins_enable"
load_rc_config ${name}

# generated by ansible
jenkins_jnlpurl="https://ci.nodejs.org/computer/{{ inventory_hostname }}/slave-agent.jnlp"
jenkins_secret="{{ secret }}"
jenkins_user="{{ server_user }}"
jenkins_group="{{ server_user }}"
# end generated by ansible

required_files="${procname} ${jenkins_jar}"

jenkins_env=" \
  OSTYPE=freebsd \
  NODE_COMMON_PIPE=/home/${jenkins_user}/test.pipe \
  PATH=/usr/local/libexec/ccache:/usr/local/bin:${PATH} \
  JOBS=$(getconf NPROCESSORS_ONLN) \
  CC=cc \
  CXX=c++"

jenkins_jar="/home/${jenkins_user}/slave.jar"
jenkins_log_file="/home/${jenkins_user}/${name}_console.log"
jenkins_args="-jar ${jenkins_jar} \
        -jnlpUrl ${jenkins_jnlpurl} \
        -secret ${jenkins_secret}"

# FreeBSD uses a java wrapper. Without full path pid monitoring won't work
procname=$(cat /usr/local/etc/javavms | cut -d "#" -f 1)
pidfile="/var/run/${name}/${name}.pid"
monitor_pidfile="/var/run/${name}/${name}_monitor.pid"

command="/usr/sbin/daemon"
command_args="-f -r -p ${pidfile} -P ${monitor_pidfile} ${procname} \
        ${jenkins_args} -slaveLog ${jenkins_log_file}"

start_precmd="${name}_prestart"
stop_cmd="${name}_stop"

jenkins_prestart() {
        if [ ! -f "${jenkins_log_file}" ]; then
                touch "${jenkins_log_file}"
                chown "${jenkins_user}:${jenkins_group}" "${jenkins_log_file}"
                chmod 640 "${jenkins_log_file}"
        fi
        if [ ! -d $(dirname ${pidfile}) ]; then
                install -d -o "${jenkins_user}" -g "${jenkins_group}" \
                        -m 750 $(dirname ${pidfile})
        fi

        if [ ! ${jenkins_secret} ]; then
                err 1 "You need to add a jenkins secret"
        fi
}

# Kill monitor, not java since it would respawn
jenkins_stop()
{
        if [ ! -f ${pidfile} -a ! -f ${monitor_pidfile} ]; then
                echo "${name} isn't running."
        else
                echo -n "Stopping service: ${name}"
                kill `cat ${monitor_pidfile}`
                # files are removed on exit, but be extra sure
                rm -f ${pidfile} ${monitor_pidfile}
                echo .
        fi
}

run_rc_command "$1"
